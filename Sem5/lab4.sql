SET SERVEROUTPUT ON

-- Task 1
DROP TABLE DziennikOperacji;
CREATE TABLE DziennikOperacji (
    ID_OPER NUMBER PRIMARY KEY,
    DATA DATE DEFAULT SYSDATE,
    TYP_OPERACJI VARCHAR2(10),
    TABELA VARCHAR2(50),
    LICZBA_REKORDOW_PO NUMBER
);

CREATE OR REPLACE TRIGGER LogujOperacje
AFTER INSERT OR DELETE OR UPDATE ON ZESPOLY
DECLARE
	vOperacja VARCHAR(6);
	vId NUMBER;
	vRekodry NUMBER;
BEGIN
	SELECT NVL(MAX(ID_OPER), 0) + 1 INTO vId FROM DZIENNIKOPERACJI;
	SELECT COUNT(*) INTO vRekodry FROM ZESPOLY;
	CASE
		WHEN INSERTING THEN
			vOperacja := 'INSERT';
		WHEN DELETING THEN
			vOperacja := 'DELETE';
		WHEN UPDATING THEN
			vOperacja := 'UPDATE';
	END CASE;
	INSERT INTO DZIENNIKOPERACJI values(vId, SYSDATE, 'ZESPOLY', vOperacja, vRekodry);
END;

INSERT INTO ZESPOLY VALUES (1000, 'TEST_N', 'TEST_A');

SELECT * FROM ZESPOLY;

UPDATE ZESPOLY SET NAZWA = 'TEST' WHERE ID_ZESP = 1000;

DELETE FROM ZESPOLY WHERE ID_ZESP = 1000;

SELECT * FROM DZIENNIKOPERACJI;

-- Task 2
CREATE OR REPLACE TRIGGER PokazPlace
BEFORE UPDATE OF placa_pod ON Pracownicy
FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE('Pracownik ' || :OLD.nazwisko);
    IF :OLD.placa_pod IS NOT NULL THEN
        DBMS_OUTPUT.PUT_LINE('Płaca przed modyfikacją: ' || :OLD.placa_pod);
    ELSE
        DBMS_OUTPUT.PUT_LINE('Płaca przed modyfikacją: brak');
    END IF;

    IF :NEW.placa_pod IS NOT NULL THEN
        DBMS_OUTPUT.PUT_LINE('Płaca po modyfikacji: ' || :NEW.placa_pod);
    ELSE
        DBMS_OUTPUT.PUT_LINE('Płaca po modyfikacji: brak');
    END IF;
END;

UPDATE PRACOWNICY SET PLACA_POD = NULL WHERE ID_PRAC=100;
UPDATE PRACOWNICY SET PLACA_POD = 5000 WHERE ID_PRAC=100;
UPDATE PRACOWNICY SET PLACA_POD = 4000 WHERE ID_PRAC=100;

-- Task 3
CREATE OR REPLACE TRIGGER UzupelnijPlace
BEFORE INSERT ON Pracownicy
FOR EACH ROW
DECLARE
    vPlacaMin Etaty.placa_min%TYPE;
BEGIN
    IF :NEW.etat IS NULL AND :NEW.placa_pod IS NULL THEN
        :NEW.placa_pod := 0;
    ELSIF :NEW.etat IS NOT NULL AND :NEW.placa_pod IS NULL THEN
        SELECT placa_min INTO vPlacaMin FROM Etaty WHERE nazwa = :NEW.etat;
        :NEW.placa_pod := vPlacaMin;
    END IF;
    IF :NEW.placa_dod IS NULL THEN
        :NEW.placa_dod := 0;
    END IF;
END;

ALTER TABLE PRACOWNICY DROP CONSTRAINT MIN_PLACA_POD;

INSERT INTO PRACOWNICY (ID_PRAC, NAZWISKO)
VALUES (1000, 'Kowalski');
SELECT * FROM PRACOWNICY WHERE ID_PRAC=1000;

INSERT INTO PRACOWNICY (ID_PRAC, NAZWISKO, ETAT)
VALUES (1001, 'Nowak', 'PROFESOR');
SELECT * FROM PRACOWNICY WHERE ID_PRAC=1001;

INSERT INTO PRACOWNICY (ID_PRAC, NAZWISKO, ETAT, PLACA_POD, PLACA_DOD)
VALUES (1002, 'Kowal', 'PROFESOR', 10, 10);
SELECT * FROM PRACOWNICY WHERE ID_PRAC=1002;

DELETE FROM PRACOWNICY WHERE ID_PRAC IN (1000, 1001, 1002);

-- Task 4
SELECT MAX(ID_ZESP) FROM ZESPOLY;

CREATE SEQUENCE SEQ_Zespoly
START WITH 101
INCREMENT BY 1;

CREATE OR REPLACE TRIGGER UzupelnijID
BEFORE INSERT ON Zespoly
FOR EACH ROW
BEGIN
    IF :NEW.id_zesp IS NULL THEN
        SELECT SEQ_Zespoly.NEXTVAL INTO :NEW.id_zesp FROM DUAL;
    END IF;
END;

INSERT INTO Zespoly(nazwa, adres) VALUES('NOWY', 'brak');

SELECT * FROM ZESPOLY;

-- Task 5
CREATE OR REPLACE VIEW Szefowie
    (szef, pracownicy)
AS
SELECT p2.NAZWISKO, COUNT(p2.NAZWISKO)
FROM PRACOWNICY p1 JOIN PRACOWNICY p2 ON (p1.ID_SZEFA = p2.ID_PRAC)
GROUP BY p2.NAZWISKO;

CREATE OR REPLACE TRIGGER UsunSzefa
INSTEAD OF DELETE ON Szefowie
DECLARE
    vPodwladni INTEGER;
BEGIN
    SELECT COUNT(*) INTO vPodwladni FROM PRACOWNICY WHERE ID_SZEFA IN (SELECT ID_PRAC FROM PRACOWNICY
    WHERE ID_SZEFA IN (SELECT ID_PRAC FROM PRACOWNICY WHERE NAZWISKO = :OLD.SZEF));

    IF vPodwladni > 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Jeden z podwładnych usuwanego szefa jest szefem innych pracowników. Usuwanie anulowane!');
    END IF;

    DELETE FROM PRACOWNICY
    WHERE ID_SZEFA IN (SELECT ID_PRAC FROM PRACOWNICY WHERE NAZWISKO = :OLD.SZEF);
    DELETE FROM PRACOWNICY
    WHERE ID_PRAC IN (SELECT ID_PRAC FROM PRACOWNICY WHERE NAZWISKO = :OLD.SZEF);
END;


SELECT * FROM Szefowie;

SELECT * FROM Pracownicy WHERE id_prac = 140 OR id_szefa = 140;

DELETE FROM szefowie WHERE szef='MORZY';

SELECT * FROM pracownicy WHERE id_prac = 140 OR id_szefa = 140;

ROLLBACK;

-- Task 6
ALTER TABLE ZESPOLY ADD LICZBA_PRACOWNIKOW INT DEFAULT 0;

UPDATE ZESPOLY SET LICZBA_PRACOWNIKOW = (SELECT COUNT(*) FROM PRACOWNICY WHERE PRACOWNICY.ID_ZESP = ZESPOLY.ID_ZESP);

SELECT * FROM ZESPOLY;

CREATE OR REPLACE TRIGGER dodanie_pracownika
AFTER INSERT ON PRACOWNICY
FOR EACH ROW
BEGIN
    IF :NEW.ID_ZESP IS NOT NULL THEN
        UPDATE ZESPOLY
        SET LICZBA_PRACOWNIKOW = LICZBA_PRACOWNIKOW + 1
        WHERE ID_ZESP = :NEW.ID_ZESP;
    END IF;
END;

CREATE OR REPLACE TRIGGER usuniecie_pracownika
AFTER DELETE ON PRACOWNICY
FOR EACH ROW
BEGIN
    IF :OLD.ID_ZESP IS NOT NULL THEN
        UPDATE ZESPOLY
        SET LICZBA_PRACOWNIKOW = LICZBA_PRACOWNIKOW - 1
        WHERE ID_ZESP = :OLD.ID_ZESP;
    END IF;
END;

CREATE OR REPLACE TRIGGER przesuniecie_pracownika
AFTER UPDATE ON PRACOWNICY
FOR EACH ROW
BEGIN
    IF :OLD.ID_ZESP IS NOT NULL THEN
        UPDATE Zespoly
        SET liczba_pracownikow = liczba_pracownikow - 1
        WHERE ID_ZESP = :OLD.ID_ZESP;
    END IF;

    IF :NEW.ID_ZESP IS NOT NULL THEN
        UPDATE Zespoly
        SET liczba_pracownikow = liczba_pracownikow + 1
        WHERE ID_ZESP = :NEW.ID_ZESP;
    END IF;
END;

INSERT INTO Pracownicy(id_prac, nazwisko, id_zesp, id_szefa) VALUES(300,'NOWY PRACOWNIK',40,120);
SELECT * FROM Zespoly;

UPDATE Pracownicy SET id_zesp = 10 WHERE id_zesp = 30;
SELECT * FROM Zespoly;

DELETE FROM PRACOWNICY WHERE ID_PRAC = 300;
SELECT * FROM Zespoly;

-- Task 7
ALTER TABLE Pracownicy DROP CONSTRAINT FK_ID_SZEFA;

ALTER TABLE Pracownicy ADD CONSTRAINT FK_ID_SZEFA
FOREIGN KEY (ID_SZEFA) REFERENCES Pracownicy(ID_PRAC)
ON DELETE CASCADE;

CREATE OR REPLACE TRIGGER Usun_Prac
AFTER DELETE ON PRACOWNICY
FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE('Usunięto: ' || :OLD.NAZWISKO);
END;

DELETE FROM PRACOWNICY WHERE NAZWISKO = 'MORZY';

ROLLBACK;

CREATE OR REPLACE TRIGGER Usun_Prac
BEFORE DELETE ON PRACOWNICY
FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE('Usuwany pracownik: ' || :OLD.NAZWISKO);
END;

DELETE FROM PRACOWNICY WHERE NAZWISKO = 'MORZY';

ROLLBACK;

-- Task 8
ALTER TABLE PRACOWNICY DISABLE ALL TRIGGERS;

SELECT trigger_name, trigger_type, triggering_event, table_name, when_clause, status
FROM User_Triggers
WHERE table_name IN ('PRACOWNICY', 'ZESPOLY')
ORDER BY table_name, trigger_name;

UPDATE PRACOWNICY SET PLACA_POD = NULL WHERE ID_PRAC=100;
UPDATE PRACOWNICY SET PLACA_POD = 5000 WHERE ID_PRAC=100;
UPDATE PRACOWNICY SET PLACA_POD = 4000 WHERE ID_PRAC=100;

INSERT INTO PRACOWNICY (ID_PRAC, NAZWISKO, ETAT)
VALUES (1001, 'Nowak', 'PROFESOR');

SELECT * FROM PRACOWNICY WHERE ID_PRAC=1001;

DELETE FROM PRACOWNICY WHERE ID_PRAC = 1001;

-- Task 9
SELECT TRIGGER_NAME 
FROM USER_TRIGGERS 
WHERE TABLE_NAME IN ('ZESPOLY', 'PRACOWNICY');

DROP TRIGGER DODANIE_PRACOWNIKA;
DROP TRIGGER LOGUJOPERACJE;
DROP TRIGGER POKAZPLACE;
DROP TRIGGER PRZESUNIECIE_PRACOWNIKA;
DROP TRIGGER USUNIECIE_PRACOWNIKA;
DROP TRIGGER USUN_PRAC;
DROP TRIGGER UZUPELNIJID;
DROP TRIGGER UZUPELNIJPLACE;